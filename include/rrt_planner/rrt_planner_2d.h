/**
 * @file rrt_planner_2d.h
 * @author Borna Zbodulja (borna.zbodulja@gmail.com)
 * @brief RRT planner 2D plugin
 * @version 0.1
 * @date 2023-05-13
 *
 * @copyright Copyright (c) 2023
 *
 */

#ifndef RRT_PLANNER__RRT_PLANNER_2D_H_
#define RRT_PLANNER__RRT_PLANNER_2D_H_

#include <costmap_2d/costmap_2d.h>
#include <costmap_2d/costmap_2d_ros.h>
#include <geometry_msgs/Pose.h>
#include <geometry_msgs/PoseStamped.h>
#include <nav_core/base_global_planner.h>
#include <ros/node_handle.h>

#include <algorithm>
#include <functional>
#include <memory>
#include <optional>

#include "rrt_planner/motion_model.h"
#include "rrt_planner/rrt_star.h"
#include "rrt_planner/search_info.h"
#include "rrt_planner/utils.h"
#include "rrt_planner/visualization.h"

namespace rrt_planner {

/**
 * @brief RRT Planner 2D global planner plugin
 */
class RRTPlanner2D : public nav_core::BaseGlobalPlanner {
 public:
  using WorldCoordinatesGetter =
      std::function<geometry_msgs::Pose(const Node2D::Coordinates&)>;
  using PlanT = std::vector<geometry_msgs::PoseStamped>;
  using Plan2DT = std::optional<Node2D::CoordinatesVector>;
  using EdgeT = std::pair<Node2D::Coordinates, Node2D::Coordinates>;
  using TreeMsg = std::vector<EdgeT>;

  /**
   * @brief Empty constructor for planner
   */
  RRTPlanner2D();

  /**
   * @brief Constructor for planner
   * @param name
   * @param costmap_ros
   */
  RRTPlanner2D(std::string name, costmap_2d::Costmap2DROS* costmap_ros);

  /**
   * @brief Destructor for planner
   */
  ~RRTPlanner2D();

  /**
   * @brief Initializes planner
   * @param name Name of the planner
   * @param costmap_ros Costmap 2D ROS pointer
   */
  void initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros);

  /**
   * @brief Main planning method
   * @param start Start pose for planning
   * @param goal Goal pose for planning
   * @param plan Generated plan
   * @return True if planning was successful, false otherwise
   */
  bool makePlan(const geometry_msgs::PoseStamped& start,
                const geometry_msgs::PoseStamped& goal, PlanT& plan);

 protected:
  /**
   * @brief Loads planning parameters from param server
   */
  void LoadParams();

  /**
   * @brief Creates 2D path using RRT* algorithm
   * @param start_mx Start X position in map frame
   * @param start_my Start Y position in map fram
   * @param goal_mx Goal X position in map frame
   * @param goal_my Goal Y position in map fram
   * @return 2D plan if planning was successful, nullopt otherwise
   */
  Plan2DT CreatePath(const unsigned int& start_mx, const unsigned int& start_my,
                     const unsigned int& goal_mx, const unsigned int& goal_my);

  /**
   * @brief Process path received from planner
   * @param path 2D path generated by planner
   * @param start Start pose for planning
   * @param goal Goal pose for planning
   * @return PlanT Final plan
   */
  PlanT ProcessPath(Node2D::CoordinatesVector& path,
                    const geometry_msgs::PoseStamped& start,
                    const geometry_msgs::PoseStamped& goal);

  /**
   * @brief Publishes plan and search tree visualization
   */
  inline void PublishVisualization() {
    visualization_handler_->PublishVisualization();
  }

  /**
   * @brief Clears plan and search tree visualization
   */
  inline void ClearVisualization() {
    visualization_handler_->ClearVisualization();
  }

  /**
   * @brief Updates plan and search tree visualization
   * @param plan
   * @param start_tree
   * @param goal_tree
   */
  void UpdateVisualization(const PlanT& plan, const TreeMsg& start_tree,
                           const TreeMsg& goal_tree);

  bool initialized_{false};
  // Costmap 2D pointer
  costmap_2d::Costmap2D* costmap_{nullptr};
  // Private Node handle
  ros::NodeHandle nh_;
  // RRT* planner pointer
  std::unique_ptr<RRTStar<Node2D>> rrt_star_;
  // Visualization handler
  std::shared_ptr<Visualization<Node2D>> visualization_handler_;
  // Collision checker pointer
  CollisionCheckerPtr collision_checker_;
  // Motion model
  MotionModel motion_model_;
  // Search info
  SearchInfo search_info_;
};

}  // namespace rrt_planner

#endif
